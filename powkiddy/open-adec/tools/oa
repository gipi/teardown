#!/usr/bin/env python3
"""
Script to interact with open-adec.

It uploads the open-adec binary and it's possible to interact via USB packets.
"""
import os
import sys
import logging
import argparse
import functools
import tqdm
import struct

# import our module
sys.path.insert(0, 
    os.path.join(os.path.dirname(__file__), "..", "..", "..",
    "meta", "actions", "adfu"))

from adfu.cbw import usb_conf, ADECadfus, cbw_send, cbw_read_response


logging.basicConfig()
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


def argparse_vendor_product(value):
    vendor, product = tuple(value.split(":"))

    return int(vendor, 16), int(product, 16)


def parse_args():
    args = argparse.ArgumentParser(description='open-adec swiss knife tool')

    args.add_argument(
        '--device',
        type=argparse_vendor_product,
        required=True,
        help="vendor:product of the device you want to interact with")
    # FIXME: some args are mandatory depending on the command
    args.add_argument('--binary', required=True)
    args.add_argument('--address', type=functools.partial(int, base=0), default=0xb4060000)
    args.add_argument('--output', type=argparse.FileType('wb'))
    args.add_argument('--memory', type=functools.partial(int, base=0))
    args.add_argument('--length', type=functools.partial(int, base=0))

    args.add_argument(
        'command',
        choices=[
            'flashdump',
            'memdump',
            'stacktrace',
        ],
        help='actions available',
    )

    return args.parse_args()


def flashdump(ep_read, ep_write, output):

    logger.info("asking for a flash dump")
    cbw_send(ep_write, 0xa, 0x00, 0xcafebabe, 0xdeadbeef, 0xbadc0de)

    # receive the size of the flash
    str_size = ep_read.read(0x4)
    npackets = struct.unpack("I", str_size)[0]

    size_packet = ep_read.wMaxPacketSize

    logger.info(f'write dump of {npackets} sectors ({size_packet=}) to "{output}"')
    for _ in  tqdm.trange(npackets):
        data = ep_read.read(0x200)

        output.write(data)

    cbw_read_response(ep_read)


def memdump(ep_read, ep_write, address, length, output):
    logger.info(f"asking for memory dump of {length:x} bytes, starting from {address:x}")

    cbw_send(ep_write, 0xb, 0x00, address, length, 0x00)

    data = ep_read.read(length)

    output.write(data)

    cbw_read_response(ep_read)


def stacktrace(ep_read, ep_write):
    logger.info("asking for a stacktrace (look at the UART output to see it)")
    cbw_send(ep_write, 0xab, 0x00, 0x00, 0x00, 0x00)

    cbw_read_response(ep_read)


if __name__ == '__main__':
    args = parse_args()

    dev, endpoint_read, endpoint_write = usb_conf(*args.device)

    if not dev:
        raise Exception("device not found")

    logger.info(f"uploading binary '{args.binary}' and executing it at {args.address:x}")
    # try to use the standard code from Actions
    ADECadfus(args.binary, endpoint_read, endpoint_write, address=args.address)

    if args.command == 'flashdump':
        flashdump(endpoint_read, endpoint_write, args.output)
    elif args.command == 'memdump':
        memdump(endpoint_read, endpoint_write, args.memory, args.length, args.output)
    elif args.command == 'stacktrace':
        stacktrace(endpoint_read, endpoint_write)

    # reset the board (if we disconnect it's not possible to reconnect
    # and issue commands, it's not clear if a problem with the firmware,
    # pyusb or the USB controller)
    cbw_send(endpoint_write, 0xff, 0x00, 0x00, 0x00, 0x00)
    cbw_read_response(endpoint_read)
